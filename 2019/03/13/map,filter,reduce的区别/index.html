<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>Hexo</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/syq1035"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">随笔</h1><ul class="meta"><li><i class="icon icon-author"></i>syq</li><li><i class="icon icon-clock"></i>18 Minutes</li><li><i class="icon icon-calendar"></i>March 13, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><h1 id="map-filter-reduce的区别"><a href="#map-filter-reduce的区别" class="headerlink" title="map,filter,reduce的区别"></a>map,filter,reduce的区别</h1><h1 id="map-filter-reduce的区别-1"><a href="#map-filter-reduce的区别-1" class="headerlink" title="map,filter,reduce的区别"></a>map,filter,reduce的区别</h1><h6 id="一张图及其形象的说明："><a href="#一张图及其形象的说明：" class="headerlink" title="一张图及其形象的说明："></a>一张图及其形象的说明：</h6><p><img src="http://ow47touqj.bkt.clouddn.com/filter_map_reduce.png" alt="知乎用户提供"></p>
<h2 id="一-map"><a href="#一-map" class="headerlink" title="一.map"></a>一.map</h2><p><strong>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</strong><br>用一张图来说明：<br><img src="https://www.liaoxuefeng.com/files/attachments/0013879622109990efbf9d781704b02994ba96765595f56000/0" alt="来自廖雪峰的"><br>代码实例：（初学者简单的使用就好了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 5, 10, 15];</span><br><span class="line">let doubles = numbers.map((x) =&gt; &#123;</span><br><span class="line">   return x * 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// doubles is now [2, 10, 20, 30]</span><br><span class="line">// numbers is still [1, 5, 10, 15]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let numbers = [1, 4, 9];</span><br><span class="line">let roots = numbers.map(Math.sqrt);</span><br><span class="line"></span><br><span class="line">// roots is now [1, 2, 3]</span><br><span class="line">// numbers is still [1, 4, 9]</span><br></pre></td></tr></table></figure>
<h5 id="map-的真正的语法："><a href="#map-的真正的语法：" class="headerlink" title="map()的真正的语法："></a>map()的真正的语法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = arr.map(function callback(currentValue, index, array) &#123; </span><br><span class="line">    // Return element for new_array </span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>callback 生成新数组元素的函数，使用三个参数：<br><strong>currentValue</strong><br>callback 的第一个参数，数组中正在处理的当前元素。<br><strong>index</strong><br>callback 的第二个参数，数组中正在处理的当前元素的索引。<br><strong>array</strong><br>callback 的第三个参数，map 方法被调用的数组。</p>
<p>thisArg<br>可选的。执行 callback 函数时 使用的this 值。<br>返回值<br>一个新数组，每个元素都是回调函数的结果。<br>运行说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = [1,2,3,4,5,2,6,10] ;</span><br><span class="line">let b =a.map(function(value,index,array)&#123;</span><br><span class="line">    console.log(value,index,array);</span><br><span class="line">&#125;)</span><br><span class="line">//1 0 [1,2,3,4,5,2,6,10]</span><br><span class="line">//2 1 [1,2,3,4,5,2,6,10]</span><br><span class="line">//3 2 [1,2,3,4,5,2,6,10]...</span><br></pre></td></tr></table></figure>
<p>暂时还不知道thisArg的用法（^-^）,所有最多用两个参数好了<br>来自微软的map说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Define an object that contains a divisor property and</span><br><span class="line">// a remainder function.</span><br><span class="line">var obj = &#123;</span><br><span class="line">    divisor: 10,</span><br><span class="line">    remainder: function (value) &#123;</span><br><span class="line">        return value % this.divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create an array.</span><br><span class="line">var numbers = [6, 12, 25, 30];</span><br><span class="line"></span><br><span class="line">// Get the remainders.</span><br><span class="line">// The obj argument specifies the this value in the callback function.</span><br><span class="line">var result = numbers.map(obj.remainder, obj);</span><br><span class="line">document.write(result);</span><br><span class="line"></span><br><span class="line">// Output:</span><br><span class="line">// 6,2,5,0</span><br></pre></td></tr></table></figure>
<p>暂时就先这样吧，以后再改<br>碰到的一个有趣的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt)//会得到什么?</span><br><span class="line">// 你可能觉的会是[1, 2, 3]</span><br><span class="line">//但是现实总是残酷的</span><br><span class="line">// 但实际的结果是 [1, NaN, NaN]</span><br><span class="line">// 通常使用parseInt时,只需要传递一个参数.</span><br><span class="line">// 但实际上,parseInt可以有两个参数.第二个参数是进制数.</span><br><span class="line">// 可以通过语句&quot;alert(parseInt.length)===2&quot;来验证.</span><br><span class="line">// map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, </span><br><span class="line">// 元素索引, 原数组本身.</span><br><span class="line">// 第三个参数parseInt会忽视, 但第二个参数不会,也就是说,</span><br><span class="line">// parseInt把传过来的索引值当成进制数来使用.从而返回了NaN.</span><br><span class="line"></span><br><span class="line">function returnInt(element) &#123;</span><br><span class="line">  return parseInt(element, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(returnInt); // [1, 2, 3]</span><br><span class="line">// 意料之中的结果</span><br><span class="line"></span><br><span class="line">// 也可以使用简单的箭头函数，结果同上</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map( str =&gt; parseInt(str) );</span><br><span class="line"></span><br><span class="line">// 一个更简单的方式:</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(Number); // [1, 2, 3]</span><br><span class="line">// 与`parseInt` 不同，下面的结果会返回浮点数或指数:</span><br><span class="line">[&apos;1.1&apos;, &apos;2.2e2&apos;, &apos;3e300&apos;].map(Number); // [1.1, 220, 3e+300]</span><br></pre></td></tr></table></figure>
<h2 id="二-filter"><a href="#二-filter" class="headerlink" title="二.filter"></a>二.filter</h2><p><strong>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</strong><br>和上面一样，直接拿代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function isBigEnough(value) &#123;</span><br><span class="line">  return value &gt;= 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);</span><br><span class="line"></span><br><span class="line">// filtered is [12, 130, 44]</span><br><span class="line"></span><br><span class="line">// ES6 way</span><br><span class="line"></span><br><span class="line">const isBigEnough = value =&gt; value &gt;= 10;//很骚的函数</span><br><span class="line"></span><br><span class="line">let [...spraed]= [12, 5, 8, 130, 44];//解构赋值</span><br><span class="line"></span><br><span class="line">let filtered = spraed.filter(isBigEnough);</span><br><span class="line"></span><br><span class="line">// filtered is [12, 130, 44]</span><br></pre></td></tr></table></figure>
<p>语法可以参考map的，这里就简单说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var new_array = arr.filter(callback[, thisArg])</span><br></pre></td></tr></table></figure>
<p><strong>callback</strong><br>用来测试数组的每个元素的函数。调用时使用参数 (<em>element</em>, <em>index</em>, <em>array</em>)。<br>返回true表示保留该元素（通过测试），false则不保留。<br><strong>thisArg</strong><br>可选。执行 callback 时的用于 this 的值。<br>返回值<br>一个新的通过测试的元素的集合的数组</p>
<h2 id="三-reduce"><a href="#三-reduce" class="headerlink" title="三.reduce"></a>三.reduce</h2><p><strong>reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var total = [0, 1, 2, 3].reduce(function(sum, value) &#123;</span><br><span class="line">  return sum + value;</span><br><span class="line">&#125;, 0);</span><br><span class="line">// total is 6</span><br><span class="line">//居然可以用reduce降维</span><br><span class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</span><br><span class="line">  return a.concat(b);</span><br><span class="line">&#125;, []);</span><br><span class="line">// flattened is [0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)</span><br></pre></td></tr></table></figure>
<p>说明<br>callback<br>执行数组中每个值的函数，包含四个参数<br><strong>accumulator</strong><br>上一次调用回调返回的值，或者是提供的初始值（initialValue）<br><strong>currentValue</strong><br>数组中正在处理的元素<br><strong>currentIndex</strong><br>数据中正在处理的元素索引，如果提供了 initialValue ，从0开始；否则从1开始<br><strong>array</strong><br>调用 reduce 的数组<br><strong>initialValue</strong><br>可选项，其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。空数组调用reduce时没有设置初始值将会报错。<br>返回值<br>函数累计处理的结果<br><strong>注意</strong>:<br>不提供 initialValue ，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。提供 initialValue ，从索引0开始。</p>
<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>
<p>提供 initialValue 通常更安全，正如下面的例子，如果没有提供initialValue，则可能有三种输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var maxCallback = ( pre, cur ) =&gt; Math.max( pre.x, cur.x );</span><br><span class="line">var maxCallback2 = ( max, cur ) =&gt; Math.max( max, cur );</span><br><span class="line"></span><br><span class="line">// reduce() without initialValue</span><br><span class="line">[ &#123; x: 22 &#125;, &#123; x: 42 &#125; ].reduce( maxCallback ); // 42</span><br><span class="line">[ &#123; x: 22 &#125;            ].reduce( maxCallback ); // &#123; x: 22 &#125;</span><br><span class="line">[                      ].reduce( maxCallback ); // TypeError</span><br><span class="line"></span><br><span class="line">// map/reduce; better solution, also works for empty arrays</span><br><span class="line">[ &#123; x: 22 &#125;, &#123; x: 42 &#125; ].map( el =&gt; el.x )</span><br><span class="line">                        .reduce( maxCallback2, -Infinity );</span><br></pre></td></tr></table></figure>
<p><strong>reduce的运行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array)&#123;</span><br><span class="line">  return accumulator + currentValue;</span><br><span class="line">//箭头操作</span><br><span class="line">[0, 1, 2, 3, 4].reduce( (prev, curr) =&gt; prev + curr );</span><br><span class="line">//同样的结果</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>懒得弄表格了，直接上图<br><img src="http://ow47touqj.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170922162803.png" alt="来自MDN截图"><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">相关reduce文档(来自MDN)</a><br>相信你看了这么多，应该可以简单的使用这三个函数了</p>
<h3 id="再讲一下foreach吧"><a href="#再讲一下foreach吧" class="headerlink" title="再讲一下foreach吧"></a>再讲一下foreach吧</h3><p><strong>forEach() 方法对数组的每个元素执行一次提供的函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.forEach(function(element) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// c</span><br></pre></td></tr></table></figure>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(callback(currentValue, index, array)&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;, this)</span><br><span class="line"></span><br><span class="line">array.forEach(callback[, thisArg])</span><br></pre></td></tr></table></figure>
<p>现在，你会发现foreach和map,reduce好像可以通用,的确，在某些方面你随便用哪个都可以。<br>但是，你需要知道foreach的返回值是undefined<br><strong>参数</strong><br><em>callback</em><br>为数组中每个元素执行的函数，该函数接收三个参数：<br><em>currentValue</em>(当前值)<br>数组中正在处理的当前元素。<br><em>index</em>(索引)<br>数组中正在处理的当前元素的索引。<br><em>array</em><br>forEach()方法正在操作的数组。<br>thisArg可选<br>可选参数。当执行回调 函数时用作this的值(参考对象)。<br><strong>返回值</strong><br>undefined.<br>个人不建议使用这个东西，不为什么，就任性 ;<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">详情请参考MND文档</a></p>
</div><div class="article-meta" style="max-width:800px"></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjt77007200078gva5u3xw8pc" data-title data-url="http://yoursite.com/2019/03/13/map,filter,reduce的区别/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2019/03/13/node+express实现个性化聊天室/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2019/03/13/JS取整/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/syq1035" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.segmentfault.com/" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 Hexo<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>